#### 线上OJ：
> 一本通：http://ybt.ssoier.cn:8088/problem_show.php?pid=1967  
AcWing：https://www.acwing.com/problem/content/461/  
洛谷：https://www.luogu.com.cn/problem/P2239  

#### 背景知识：
螺旋矩阵可以采用模拟的方式生成。就是顺时针四个方向  
> 第1步、是**第 1 行**，方向为**从左到右**，数值+1。当向**右**遇到 **边界n** 或者 **格子已填过数值** 时停止  
第2步、是**第 n 列**，方向为**从上到下**，数值+1。当向**下**遇到 **边界n** 或者 **格子已填过数值** 时停止  
第3步、是**第 n 行**，方向为**从右到左**，数值+1。当向**左**遇到 **边界0** 或者 **格子已填过数值** 时停止  
第4步、是**第 1 列**，方向为**从下到上**，数值+1。当向**上**遇到 **边界0** 或者 **格子已填过数值** 时停止  

以上四步为一轮。然后开始下一轮，直至数值填满达到 n*n 为止。  

本题的第一种**常规解法**，是先**生成螺旋矩阵**，然后输出其中的数值。但是题中的n会达到30000，此时开a[n][n]的二位矩阵在空间上会爆，所以这种方法只能拿50分。

import { Bleed, Callout, Tabs, Steps} from "nextra-theme-docs"


<Tabs items={['解法一、50%分数', '解法二、dfs', '解法三、公式推导']}>
  <Tabs.Tab> 

代码如下：
```cpp filename="先生成矩阵，再输出（50%分数）" showLineNumbers {18,19,21}
#include <bits/stdc++.h>
using namespace std;
const int maxn = 10005;
int a[maxn][maxn];
int n, i ,j;
int dx[4]={0, 1, 0, -1};
int dy[4]={1, 0, -1, 0};

void cal() {
    int x = 0, y = 0;
    a[x][y] = 1;
    for (int k = 2; k <= n * n; )
    {
        for(int t = 0; t < 4; t++)
        {
            while (1)
            {
                int nx = x + dx[t], ny = y + dy[t];
                if (nx < 0 || nx >= n || ny < 0 || ny >= n || a[nx][ny])  break;

                a[x = nx][y = ny] = k++;
            }
        }     
    }
}
int main() {
    cin >> n >> i >> j;
    cal();
    cout << a[i-1][j-1];
    return 0;
}
```

  </Tabs.Tab>

  <Tabs.Tab> 
  以上代码的二位矩阵会爆，故需要进行优化。由于本题中只需要输出 a[i][j] 的值，并不需要生成整个螺旋矩阵。故可以考虑通过递归来计算 a[i][j]。

  #### 核心思想：
  由于螺旋矩阵每次只能顺序计算最外圈，故我们可以根据矩阵的 n 和 i j 推断出最外圈每个位置的计算公式（如下图所示）。

import Image from 'next/image'
 
<Image src="/image/14pj31.png" alt="样例图" width={720} height={204} />

公式1（外圈数值）：   
<Callout type="default">
第 1 行，a[1][j] = j               // 如果剥离外层后，所求点处于当前矩阵的第一行，则行坐标就是值  
第 n 列，a[i][n] = n+i-1      // 如果剥离外层后，所求点处于当前矩阵的最后一列，则 i+n-1 就是值（从上往下走）  
第 n 行，a[n][j] = 3n - j - 1 // 如果剥离外层后，所求点处于当前矩阵的最后一行，则 2n-1+n-j = 3n-j-1 就是值  
第 1 列，a[i][1] = 4n-i-2;       // 如果剥离外层后，所求点处于当前矩阵的第一列，则 3n-2+n-i= 4n-i-2就是值  
</Callout>

光有外圈的计算公式还不足以计算内圈a[i][j]，需要知晓每次剥去外圈向内传递时的差值。

<Image src="/image/14pj32.png" alt="样例图" width={832} height={212} />

从上图中，我们可以发现，a[1][1]=1，传到a[2][2]的增量为**当前 n-1 的4倍**。
> 比如：n=9 时，增量为4*(9-1)=32  
比如：n=7 时，增量为4*(7-1)=24  
比如：n=5 时，增量为4*(5-1)=16  

综上所述，可以先**深搜 a[i][j] 达到最外层**，使其可直接计算。然后**再层层递归回来**，每次**递归回时加上增量 4(n-1) **即可。
代码如下

```cpp filename="解法二、dfs" showLineNumbers {15}
#include <bits/stdc++.h>
using namespace std;

int n, i, j;

// 剥离外圈向内传递时，n减少2（因为行、列各减少2），i和j各减少1
// a[1][1]到a[2][2]的增量为 (n-1)*4
int dfs(int n, int i, int j)
{
    if(i == 1)  return j;             // 如果剥离外层后，所求点处于当前矩阵的第一行，则行坐标就是值
    if(j == n)  return n + i - 1;     // 如果剥离外层后，所求点处于当前矩阵的最后一列，则 i+n-1 就是值（从上往下走）
    if(i == n)  return 3 * n - j - 1; // 如果剥离外层后，所求点处于当前矩阵的最后一行，则 2n-1+n-j = 3n-j-1 就是值
    if(j == 1)  return 4 * n - i - 2; // 如果剥离外层后，所求点处于当前矩阵的第一列，则 3n-2+n-i= 4n-i-2就是值

    return dfs(n-2, i-1, j-1) + (n-1)*4;  // 如果剥离外层后，所求点还没到外圈，则继续剥离本圈
}

// 在已知 n 的前提下，最外圈的坐标可以直接求出
// 如果不在最外圈，就一层一层剥离，直到所求点处于最外圈
int main()
{
    cin >> n >> i >> j;
    cout << dfs(n, i, j);
    return 0;
}
```

  </Tabs.Tab>


   <Tabs.Tab>
在解法二中采用了深搜，当 a[i][j] 处于内圈时，依然有较高的复杂度。实际上，当我们在分析图二时，已经可以发现，a[1][1]可以一直向下传递。

<Image src="/image/14pj33.png" alt="样例图" width={360} height={200} />

> 其中，  
1、a[1][1] → a[2][2]，增量为 32，即 4*(9-1) = 4*(n-1)  
2、a[2][2] → a[3][3]，增量为 24，即 4*(9-1) - 8 = 4*(n-1) - 8。所以 $$a[3][3] = a[2][2]+ 4*(n-1) - 8 = 2* 4*(n-1) - 8 $$  
3、a[3][3] → a[4][4]，增量为 16，即 4*(9-1) - 8 - 8 = 4*(n-1) - 2*8。所以 $$a[4][4] = a[3][3]+ 4*(n-1) - 2*8 = 3* 4*(n-1) - 3*8$$  
4、a[4][4] → a[5][5]，增量为 8，即 4*(9-1) - 8 - 8-8 = 4*(n-1) - 3*8。所以 $$a[5][5] = a[4][4]+ 4*(n-1) - 3*8 = 4* 4*(n-1) - 6*8$$  
所以，剥离 k 层后的起始元素可表示为：  $$k*4*(n-1) - (k-1)*(8+(k-1)*8)/2$$   

也就是说，我们不需要通过 dfs 也可以直接穿透到 a[i][j] 所在的那一个圈。


公式2（剥离 k 层后的起始元素）：  
<Callout type="default">
$$st = k*4*(n-1) - (k-1)*(8+(k-1)*8)/2$$
</Callout>

步骤如下（假设我们要计算是的 a[4][5]）：
>  第一步：找到 a[4][5] 所在圈的第一个数值 a[4][4]， 从a[1][1]可以直接推出   
              $$a[4][4] = k*4*(n-1) - (k-1)*(8+(k-1)*8)/2$$  
第二步：在a[4][5] 所在圈内，按照公式1推出增量  
第三步：前两步的数值相加  

公式推导后的时间复杂度为O(1)，代码见下
```cpp filename="解法三、公式推导（ O(1)）" showLineNumbers {25,27,29}
#include <bits/stdc++.h>
using namespace std;

int n, i, j;

// 剥离外圈向下传递时，n减少2（因为行、列各减少2），ℹ和j各减少1
int solve(int n, int i, int j)
{
    if(i == 1)  return j;             // 如果剥离外层后，所求点处于当前矩阵的第一行，则行坐标就是值
    if(j == n)  return n + i - 1;     // 如果剥离外层后，所求点处于当前矩阵的最后一列，则 i+n-1 就是值（从上往下走）
    if(i == n)  return 3 * n - j - 1; // 如果剥离外层后，所求点处于当前矩阵的最后一行，则 2n-1+n-j = 3n-j-1 就是值
    if(j == 1)  return 4 * n - i - 2; // 如果剥离外层后，所求点处于当前矩阵的第一列，则 3n-2+n-i= 4n-i-2就是值
}

// a[i][j] = st + increase
int main()
{
    cin >> n >> i >> j;
    if(i > n || j > n)
        return 0;
    else if(i == 1 || j == 1)
        cout << solve(n, i, j);
    else
    {
        int k = min(min(n-i, n-j), min(i, j) - 1); // a[i][j]处于第k层
        // 4(n-1)-0*8+4(n-1)-1*8+4(n-1)-2*8+4(n-1)-3*8 = k*4*(n-1) - (0*8+1*8+2*8+3*8+...(k-1)*8) = (k-1)(8+(k-1)*8)/2
        int st = k*4*(n-1) - (k-1)*(8+(k-1)*8)/2;

        cout << st + solve(n-2*k, i-k, j-k);
    }

    return 0;
}
```

    </Tabs.Tab>

</Tabs>